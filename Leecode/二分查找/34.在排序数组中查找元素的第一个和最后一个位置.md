给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

**输入：** nums = [`5,7,7,8,8,10]`, target = 8
**输出：**[3,4]

**示例 2：**

**输入：** nums = [`5,7,7,8,8,10]`, target = 6
**输出：**[-1,-1]

**示例 3：**

**输入：** nums = [], target = 0
**输出：**[-1,-1]

```Python
def lower_bound(nums:List[int],target:int)->int: # 第一个>=target的位置
    left=0
    right=len(nums)-1 # 闭区间[left,right]
    while left<=right: # 区间不为空
        #left+(right-left)//2
        mid=(left+right)//2
        if nums[mid]<target:
            left=mid+1 # [mid+1,right]
        else:
            right=mid-1 # [left,mid-1]
    return left
        
def lower_bound2(nums:List[int],target:int)->int:
    left=0
    right=len(nums) # 左闭右开区间[left,right)
    while left<right: # 区间不为空
    #left+(right-left)//2
        mid=(left+right)//2
        if nums[mid]<target:
            left=mid+1 # [mid+1,right)
        else:
            right=mid # [left,mid)
    return left # right   

def lower_bound3(nums:List[int],target:int)->int:
    left=-1
    right=len(nums) # 开区间(left,right)
    while left+1<right: # 区间不为空
    #left+(right-left)//2 = left-left//2+right//2
    mid=(left+right)//2
        if nums[mid]<target:
            left=mid # (mid,right)
        else:
            right=mid # (left,mid)
    return right
    
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        # >=target的第一个数  <=target的最后一个数 -> >=target+1的第一个数-1
        start=lower_bound(num,target)
        if start==len(nums) or nums[start]!=target:
            return [-1,-1]
        end=lower_bound(nums,target+1)-1
        return [start,end]
```


$\ge target$
$> target = \ge target+1$
$\le target = (> target) -1=(\ge target+1)-1$
$< target= (\ge target) -1$
