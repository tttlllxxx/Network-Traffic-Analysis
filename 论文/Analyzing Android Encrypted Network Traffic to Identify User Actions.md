## 1. 📌 基本信息
- **标题**：Analyzing Android Encrypted Network Traffic to Identify User Actions
- **作者**：M. Conti, L. V. Mancini, R. Spolaor and N. V. Verde
- **机构**：University of Padua, Vrije Universiteit Amsterdam, University of Rome
- **会议 / 期刊 & 年份**：_IEEE Transactions on Information Forensics and Security_，vol. 11, no. 1, pp. 114-125, Jan. 2016
- **链接 / DOI**：10.1109/TIFS.2015.2478741
- **关键词**：Time series analysis;Cryptography;Privacy;IP networks;Mobile handsets;Machine learning algorithms;Mobile communication;Cellular phones;information security;privacy

---

## 2. 🎯 研究动机与问题定义
### **研究背景**：
移动设备可能被恶意利用，侵犯人们的隐私。在大多数攻击场景中，对手利用系统的漏洞对移动设备进行本地或远程控制，从而将收集到的信息发送回某个远程web服务。SSL和TLS保护数据包的内容，但它们并不能阻止检测网络数据包模式，这些模式可能会泄露一些关于用户行为的敏感信息。
  
### **研究问题**：
攻击者不与移动设备进行主动交互，作为从网络侧嗅探设备网络流量的被动攻击者：可以通过分析加密流量来增强用户分析，以准确了解用户在手机上做了什么动作。识别用户发送电子邮件、接收电子邮件、在社交网络上浏览某人的个人资料、发布帖子或推文等动作。进而推断网络中特定用户存在，甚至直接识别出用户真实身份。
  
### **挑战 / 空白点**：
加密流量难以直接分析，且用户操作之间的差异可能微妙。

### **研究目标**：
  提出了一个框架来推断用户在手机上安装的某个应用程序上执行的特定操作。特别的，假设流量是加密的，且对手窃听（不修改）用户设备和她使用的web服务之间交换的消息。

---

## 3. 🧠 方法概述与创新点
### **方法简介**：
分析网络通信，并利用TCP/IP数据包中可用的信息（如IP地址和端口），以及大小、方向（传入/传出）和定时等其他信息。
通过使用基于机器学习的方法，每个感兴趣的应用程序都会被独立分析。
考虑了七个流行的应用程序：Facebook、Gmail、Twitter、Tumblr、Dropbox、Google+和Evernote。
对于每个应用程序：
- 首先预处理一个标记有发起它们的用户操作的网络数据包数据集
- 将它们聚类到表示循环网络流的流类型中
 - 最后进行分析，以创建一个用于馈送分类器的训练集。
- 经过训练的分类器将能够对以前从未见过的新交通痕迹进行分类。

### **总体架构**：
  预处理器：执行所有预处理步骤，能够将网络流量建模为流量分类器可以轻松处理的数据。
  分类器：执行实际的分类任务。
    在使用流量分类器之前，需要用带标签的流量数据对其进行训练，而这些数据是通过对被分析的应用程序进行人工刺激生成的。
### **理论基础：** 
#### DTW（Dynamic Time Warping）：
用于在两个随时间变化的序列（也称为时间序列）之间寻找对齐关系。
  
考虑两个表示离散信号的序列：  
$X = (x_1, \ldots, x_N)$，长度为 $N \in \mathbb{N}$；  
$Y = (y_1, \ldots, y_M)$，长度为 $M \in \mathbb{N}$。

DTW 使用一个局部距离度量 $c : \mathbb{R} \times \mathbb{R} \rightarrow \mathbb{R}_{\ge 0}$​ 来计算距离矩阵 $C \in \mathbb{R}^{N \times M}$，其中每个单元$C_{i,j}$表示 $x_i$ 和 $y_j​$之间的距离。目标是在 $X$ 和 $Y$ 之间找到一个具有最小总体代价的对齐方式。直观地说，这样一个最优对齐路径沿着距离矩阵中低代价的“谷底”前进。

一个**对齐路径**（warping path）被定义为一个序列 $p = (p_1, \ldots, p_L)$，其中 $p_l = (n_l, m_l) \in [1:N] \times [1:M]$，$l \in [1:L]l∈[1:L]$，满足以下三个条件：

1. **边界条件**（Boundary condition）：$p_1 = (1, 1)$，且 $p_L = (N, M)$；
2. **单调性条件**（Monotonicity condition）：$n_1 \le n_2 \le \ldots \le n_L$​，且 $m_1 \le m_2 \le \ldots \le m_L$；
3. **步长条件**（Step size condition）：$p_{l+1} - p_l \in \{ (0,1), (1,0), (1,1) \}$ 对于所有 $l \in [1:L-1]$。

一个**对齐路径的总成本**（total cost）是其所有元素的局部距离之和。一个**最优对齐路径**（optimal warping path）是具有最小总成本的对齐路径，记作 $p^*$。

最优对齐路径的总成本可以作为序列 $X$ 和 $Y$ 之间的距离度量。在本文中，我们用 $DTW(X, Y)$表示最优对齐路径的成本。

#### 监督和无监督学习
- 监督学习：从过去收集的标记实例或示例中学习，这些实例或示例代表了一些现实世界应用中的过去经验。生成一个推断模型，然后可用于映射或分类新实例。最优方案将允许算法正确确定看不见实例的类标签。
  **随机森林**是一种基于决策树（Decision Tree）的**集成学习方法**，它通过构建多个决策树并对它们的结果进行投票（分类任务）或平均（回归任务），来提升模型的性能和泛化能力。
  随机森林 = 多个“弱分类器”（决策树）+ 投票集成 = 强分类器
  
- 无监督学习：在未标记的数据中找到隐藏的结构。由于给学习者的例子是未标记的，因此没有错误或奖励信号来评估潜在的解决方案。
  **层次聚类**是一种**无监督学习算法**，将样本按照相似性（最优对齐路径）逐层合并或拆分，形成一个“聚类树”（dendrogram）结构。
$$d(u, v) = \sum_{\substack{1 \leq i \leq n \\ 1 \leq j \leq m}} \frac{d(u[i], v[j])}{|u| \cdot |v|}$$
	$d()$是一个距离函数，$u$和$v$分别是$n$和$m$个元素的两个簇。

### **模块划分与主要组件**：
#### 预处理器
执行所有预处理步骤。
流量：单个TCP会话期间两个对等体之间交换的TCP数据包的时间顺序序列。
1. 仅考虑传入数据包传输的字节来获得时间序列；
2. 仅考虑由传出分组传输的字节而获得的；
3. 通过组合（按时间排序）由传入和传出分组传输的字节来获得;
分类方法试图学习与特定用户行为相关的网络流的“形状”，并通过对以前看不见的网络流“形状”进行分类来识别用户行为。

预处理步骤:
1. 应用域过滤，只选择属于所分析应用程序的流；
2. 过滤剩余的流，以删除可能降低方法精度的数据包；
3. 限制了生成的时间序列的长度。
每个流经过预处理为一组时间序列，传递给下一个组件。

- 域过滤：只考虑目标IP地址所有者已明确确定与所考虑的应用程序相关的流进行进一步分析。利用了WHOIS协议。业务和其他上下文信息可用于执行域过滤。
- 数据包过滤：过滤掉所有重新传输的数据包，以及标记有ACK标志的数据包。还过滤掉了其他没有带来任何有助于描述流特征的额外信息的数据包。特别是过滤掉了为打开TCP连接而执行的三次握手，以及为关闭TCP连接而交换的数据包。
- 超时和数据包间隔：使用两种不同的技术来限制生成的时间序列的长度：超时机制和数据包区间。超时机制用于终止自4.5秒以来未收到任何新数据包的流。数据包区间用于指定要考虑的起始和结束数据包。
#### 模块分类器
执行实际的分类任务。
创建一个标记的数据集来描述我们想要分类的用户行为。标记的数据集用于训练流量分类器组件，使其能够正确分类以前看不见的数据实例。
单个用户操作会生成一组不同的流。不同的用户操作可能会生成不同的流集。分类方法基于对特定用户动作所特有的流集的检测。
使用聚集聚类方法构建流簇，类似的流将被分组在同一集群中，而不同的流将分配给不同的集群。。

两个流之间距离：假设每个流$f_i$被分解为一组$n$个时间序列$\{T_i^1，…，T_i^n\}$，$f_i$和$f_j$之间的距离定义为：
$$\text{dist}(f_i, f_j) = \sum_{k=1}^{n} w_k \times DTW(T_k^i, T_k^j)$$
其中，$w_k$是分配给特定时间序列的权重，权重的分配可以使某种时间序列相对于其他时间序列更重要。

聚类中心（leader）：聚类中心将是其集群的代表。给定一个包含流$\{f_1，…，f_n\}$的集群$C$，通过选择与集群其他成员具有最小总距离的流$f_i$来选择领导者，即：
$$\arg\min_{f_i \in C} \left( \sum_{j=1}^{n} \text{dist}(f_i, f_j) \right)$$
通过层次聚类（agglomerative clustering）识别出的每个聚类，将有一个整数特征。每个特征的取值是通过分析与某一行为相关的流量得到的。
每当执行某一行为后捕获到一个流 `f`，就会将其分配到与其距离最小的聚类中心（leader）所在的聚类中。因此，第 `k` 个特征表示的是在执行该行为后，被分配到第 `k` 个聚类 `Ck` 的流的数量。
例如，对于“发送邮件”（send mail）这个行为，如果有 2 个被标记为“发送邮件”的流被分配到了聚类 `Ck`，那么第 `k` 个特征的值就是 2。
假设总共得到了 5 个聚类（cluster C1 到 C5）。
某次用户执行了“发送邮件”的操作，产生了 10 个流。
- 其中有 2 个流被分到了 cluster C1，
- 3 个被分到 C2，
- 0 个分到 C3，
- 5 个分到 C4，
- 0 个分到 C5。
那么这个“发送邮件”的行为，就可以表示成一个特征向量： → `[2, 3, 0, 5, 0]`
### **核心技术点 / 创新点**：
  深入研究了网络流的概念和评估它们之间相似性的度量。
  使用的机器学习技术
  

---

## 4. 🧪 实验设计与分析
- **数据集**：
- **评价指标**：
- **对比方法**：
- **主要结果**：
- **消融实验**：
- **可视化图表（可贴图）**：
- **结论总结**：

---

## 5. 🧩 自己的理解与思考
- ✅ **优点**：
- ⚠️ **缺点 / 不足**：
- 💡 **改进建议**：
- 🔄 **是否可用于我的研究？如何迁移？**
- ❓ **疑问点 / 不懂的地方**：

---

## 6. 📎 附加材料（可选）
- **结构图 / 流程图**：
- **重要公式推导 / 符号解释**：
- **高亮句摘录**：

---

## ✅ 阅读状态记录
- [ ] 已粗读
- [ ] 已精读
- [ ] 已复现
- [ ] 已笔记总结
